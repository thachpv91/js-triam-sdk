import {default as xdr} from "../generated/stellar-xdr_generated";
import {Keypair} from "../keypair";
import {StrKey} from "../strkey";

/**
 * Create and fund a non existent contract.
 * @function
 * @alias Operation.createContract
 * @param {object} opts
 * @param {string} opts.contractId - contract account ID to contains a contract for.
 * @param {string} opts.startingBalance - Amount in XLM the account should be funded for. Must be greater
 *                                   than the [reserve balance amount](https://www.stellar.org/developers/learn/concepts/fees.html).
 * @param {string} opts.contractAddr - Address of contract

 * @param {object} opts.data - Address of contract
 * @param {string} [opts.data.funcName] - function name
 * @param {string|Buffer} [opts.data.contractParams] - params of contract functions
 * 
 * @param {string} opts.state - State that is returned from smart contract host
 * @param {string} [opts.source] - The source account for the create contract. Defaults to the transaction's source account.
 * @returns {xdr.CreateContractOp}
 */
export const createContract = function(opts) {

  if (!this.isValidAmount(opts.startingBalance)) {
    throw new TypeError(this.constructAmountRequirementsError('startingBalance'));
  }
  let attributes = {};
  attributes.contractId   = Keypair.fromContractKey(opts.contractId).xdrContractId();
  attributes.startingBalance = this._toXDRAmount(opts.startingBalance);

  if (!isUndefined(opts.contractAddr) && !isString(opts.contractAddr)) {
    throw new TypeError('contractAddr argument must be of type String');
  }
  attributes.contractAddr = opts.contractAddr;

  // thuannd notes start

  let data = clone(opts.data);

  if (!isUndefined(opts.data.funcName) && !isString(opts.data.funcName)) {
    throw new TypeError('funcName argument must be of type String');
  }

  if (!isString(opts.data.contractParams) && !Buffer.isBuffer(opts.data.contractParams) && opts.data.contractParams !== null) {
    throw new Error("contractParams must be a string, Buffer or null");
  }

  if (this.data) {

    this.data.funcName = opts.data.funcName;

    if (isString(opts.data.contractParams)) {
      this.data.contractParams = Buffer.from(opts.data.contractParams);
    } else {
      this.data.contractParams = opts.data.contractParams;
    }

    attributes.data = new xdr.ContractInput(this.data);
  }

  // thuannd notes end

  if (!isUndefined(opts.state) && !isString(opts.state)) {
    throw new TypeError('state argument must be of type String');
  }
  attributes.state = opts.state;

  let createContract          = new xdr.CreateContractOp(attributes);

  let opAttributes = {};
  opAttributes.body = xdr.OperationBody.createContract(createContract);
  this.setSourceAccount(opAttributes, opts);

  return new xdr.Operation(opAttributes);
};