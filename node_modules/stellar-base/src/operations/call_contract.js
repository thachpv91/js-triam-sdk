import {default as xdr} from "../generated/stellar-xdr_generated";
import {Keypair} from "../keypair";
import {StrKey} from "../strkey";
import {ContrOperation} from "./contr_operation";

/**
 * Call a contract operation.
 * @function
 * @alias Operation.callContract
 * @param {object} opts
 * @param {string} opts.contractId - Contract account ID.

 * @param {object} opts.data - Address of contract
 * @param {string} [opts.data.funcName] - function name
 * @param {string|Buffer} [opts.data.contractParams] - params of contract functions
 * 
 * @returns {xdr.CallContractOp}
 */
export const callContract = function(opts) {
  if (!StrKey.isValidContractKey(opts.contractId)) {
    throw new Error("contract is invalid");
  }


  let attributes = {};
  attributes.contractId   = Keypair.fromContractKey(opts.contractId).xdrContractId();

  // thuannd notes start

  let data = clone(opts.data);

  if (!isUndefined(opts.data.funcName) && !isString(opts.data.funcName)) {
    throw new TypeError('funcName argument must be of type String');
  }

  if (!isString(opts.data.contractParams) && !Buffer.isBuffer(opts.data.contractParams) && opts.data.contractParams !== null) {
    throw new Error("contractParams must be a string, Buffer or null");
  }

  if (this.data) {

    this.data.funcName = opts.data.funcName;

    if (isString(opts.data.contractParams)) {
      this.data.contractParams = Buffer.from(opts.data.contractParams);
    } else {
      this.data.contractParams = opts.data.contractParams;
    }

    attributes.data = new xdr.ContractInput(this.data);
  }

  attributes.contrOps = [];

  // thuannd notes end
  // ContrOperation

  let callContract             = new xdr.CallContractOp(attributes);

  let opAttributes = {};
  opAttributes.body = xdr.OperationBody.callContract(callContract);
  this.setSourceAccount(opAttributes, opts);

  return new xdr.Operation(opAttributes);
};